# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

from pathlib import Path
from typing import List, Optional
import typer
import re

from ..templates import TemplateEngine, ProjectConfig, create_template_engine

class ProjectGenerator:
    """Handles project scaffolding and file generation."""
    
    def __init__(self):
        self.template_engine = create_template_engine()
    
    def create_project_structure(self, project_dir: Path) -> None:
        """Create the basic directory structure."""
        directories = [
            project_dir / "src" / "tools",
        ]
        
        for directory in directories:
            directory.mkdir(parents=True, exist_ok=True)
            typer.echo(f"  📁 {directory.relative_to(project_dir)}/")
        
        # Create __init__.py files
        (project_dir / "src" / "__init__.py").touch()
        typer.echo(f"  📄 src/__init__.py")
    
    def generate_project_files(self, project_dir: Path, config: ProjectConfig) -> None:
        """Generate all project files from templates."""
        template_mapping = self.template_engine.get_template_mapping()
        
        for template_name, target_path in template_mapping.items():
            try:
                content = self.template_engine.render_template(template_name, config)
                file_path = project_dir / target_path
                
                # Ensure parent directory exists
                file_path.parent.mkdir(parents=True, exist_ok=True)
                
                # Write the file
                file_path.write_text(content)
                typer.echo(f"  📄 {target_path}")
                
            except Exception as e:
                typer.echo(f"  ❌ Failed to generate {target_path}: {e}", err=True)
                raise
    
    def create_additional_files(self, project_dir: Path, config: ProjectConfig) -> None:
        """Create additional files that don't use templates."""
        # Create README.md
        readme_content = f"""# {config.name}

Generated by Agent Development Toolkit.

## Quick Start

### 1. Setup
```bash
# Navigate to your agent directory
cd {config.name}

# Install Python dependencies
pip install -r requirements.txt
```

### 2. Run Your Agent

**Option A: Using environment file**
```bash
adt dev --env-file .env
```

**Option B: Using AWS profile**
```bash
adt dev --aws-profile your-profile-name
```

**Option C: Using environment variables (no options needed)**
```bash
# If you have AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY set
adt dev
```

**Option D: Custom port**
```bash
adt dev --port 3000 --env-file .env
```

Visit http://localhost:8000 (or your custom port) to interact with your agent.

## Running Without ADT

You can also run your agent independently without the CLI:

```bash
# Navigate to your agent directory
cd {config.name}

# Create virtual environment (optional but recommended)
python -m venv localvenv

# Activate the virtual environment
source localvenv/bin/activate  # On Windows: localvenv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Set up your environment variables (if using .env file)
export $(cat .env | xargs)  # On Windows: use set commands

# Run your agent directly
python -m src.agent
```

## Configuration

Edit `.agent.yaml` to change providers or model settings.
See the commented examples in the file for different provider configurations.

## Adding Tools

Add new tools with:
```bash
adt add tool my_tool_name
```

This creates a new tool file in `src/tools/` with a template to get you started.

## Project Structure

- `src/agent.py` - Main agent configuration
- `src/tools/` - Tool implementations  
- `.agent.yaml` - Agent configuration
- `requirements.txt` - Python dependencies
- `.env.example` - Environment variables template
- `Dockerfile` - Example Docker configuration for local development

## Docker Support

A `Dockerfile` is provided as an example for running your agent in a container locally. This is mainly used by the `adt dev --container` command.

**Note:** The provided Dockerfile is optimized for local development. For production deployments or cloud platforms, you may need to modify it to meet specific requirements such as:
- Security policies
- Resource constraints  
- Platform-specific configurations
- Multi-stage builds for smaller images

## Documentation

For more advanced usage, deployment options, and detailed documentation, refer to the [AgentCLI Documentation](https://github.com/strands-ai/agents-cli).
"""
        (project_dir / "README.md").write_text(readme_content)
        typer.echo(f"  📄 README.md")
    
    def validate_project_name(self, name: str) -> str:
        """Validate and normalize project name."""
        if not name:
            raise typer.BadParameter("Project name cannot be empty")
        
        if not re.match(r'^[a-zA-Z][a-zA-Z0-9_-]*$', name):
            raise typer.BadParameter(
                "Project name must start with a letter and contain only letters, numbers, hyphens, and underscores"
            )
        
        return name
    
    def create_package_name(self, project_name: str, custom_pkg: Optional[str] = None) -> str:
        """Create a valid Python package name."""
        if custom_pkg:
            pkg_name = custom_pkg
        else:
            pkg_name = re.sub(r"[^0-9a-zA-Z_]", "_", project_name)
        
        # Ensure it's a valid Python identifier
        if not pkg_name.isidentifier():
            raise typer.BadParameter(f"'{pkg_name}' is not a valid Python package name")
        
        return pkg_name
    
    def generate_project(
        self, 
        name: str, 
        pkg: Optional[str] = None,
        **config_overrides
    ) -> Path:
        """Generate a complete project."""
        # Validate inputs
        name = self.validate_project_name(name)
        pkg_name = self.create_package_name(name, pkg)
        
        project_dir = Path(name).resolve()
        if project_dir.exists():
            typer.secho(f"Directory {project_dir} already exists – aborting.", fg=typer.colors.RED)
            raise typer.Exit(1)
        
        # Create configuration
        config = ProjectConfig(name=name, pkg_name=pkg_name, **config_overrides)
        
        typer.echo(f"🚀 Creating project '{name}' (package: {pkg_name})")
        
        try:
            # Create directory structure
            self.create_project_structure(project_dir)
            
            # Generate files from templates
            self.generate_project_files(project_dir, config)
            
            # Create additional files
            self.create_additional_files(project_dir, config)
            
            typer.secho(f"\n✅ Project '{name}' created successfully!", fg=typer.colors.GREEN)
            typer.echo(f"\n💡 See {name}/README.md for all available options and detailed setup instructions")
            
            return project_dir
            
        except Exception as e:
            typer.echo(f"\n❌ Failed to create project: {e}", err=True)
            # Clean up on failure
            if project_dir.exists():
                import shutil
                shutil.rmtree(project_dir)
            raise typer.Exit(1)



def create_project_generator() -> ProjectGenerator:
    """Create and return a project generator instance."""
    return ProjectGenerator()

 